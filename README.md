# Deploying Contract Using CREATE2 on CELO:

---

## Introduction:

The following tutorial offers step-by-step instructions on how to use the Solidity CREATE2 opcode to precompute the address of a Smart Contract. It will describe the technical steps that are required to use the CREATE2 opcode in a Smart Contract. 
<br/>

[CREATE2](https://docs.openzeppelin.com/cli/2.8/deploying-with-create2) is an opcode that is used to predict the address of a contract before deployment. It precomputes the address of a contract without deploying it.

CREATE2 was introduced in [EIP-1014](https://eips.ethereum.org/EIPS/eip-1014).

## Table of Contents:

- [Deploying contract with CREATE2 on CELO](#Deploying-contract-with-create2-on-CELO)
  - [Introduction](#introduction)
  - [Table of Contents](#table-of-contents)
  - [Objectives](#objectives)
  - [Pre-requisites](#pre-requisites)
  - [Requirements](#requirements)
  - [What is CREATE2 Opcode?](#What-is-create2-Opcode)
    - [Benefits of using a CREATE2?](#benefits-of-using-create2)
    - [Differences between CREATE and CREATE2?](#Differences-between-create-and-create2?)
  - [Tutorial](#tutorial)
    - [STEP 1 - Set up Hardhat Environment](#step-1---setup-hardhat-environment)
    - [STEP 2 - Create your Smart Contracts](#step-2---create-your-smart-contracts)
      - [Factory contract Explained](#Factory-contract-explained)
      - [TestContract Explained](#TestContract-explained)
    - [STEP 3 - Deploying your contracts](#step-3---deploying-your-contracts)
    - [Conclusion](#conclusion)

## Objectives:

By the end of this tutorial you will be able to write a contract and deploy it with CREATE2 on the CELO blockchain.

## Prer-equisites:

- Understanding of Solidity: as it is the main programming language that we will be using for creating the Smart Contracts on Celo blockchain.

- Command line proficiency: like Terminal or Command Prompt(cmd) is necessary for running commands and scripts.

- Proficiency in [Hardhat](https://hardhat.org/): a development environment designed for writing, testing and deploying Smart Contracts on the Celo blockchain.

## Requirements:

- A text editor: [Visual Studio Code](https://code.visualstudio.com/download).
- Install [node.js](https://nodejs.org/en/download) (version V10. or higher).
- Install [npm](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm) (node package manager). 
- Install [MetaMask Wallet](https://metamask.io/download/).

## What is CREATE2 Opcode? :

Before we dive in, let's first understand what CREATE2 opcode is. CREATE2 is an Ethereum Virtual Machine (EVM) opcode that creates a new contracts at a deterministic address based on the contract's bytecode, a unique salt value and the hash of the code. It was introduced in the Constantinople Hard Fork in February 2019.

The CREATE2 opcode is different from the traditional create opcode, which creates a new contracts at a random address. It is deterministic and allows developers to calculate the contract address before deploying the contract.

<strong>How to use CREATE2 opcode:</strong>

To use CREATE2 opcode, we need to define three parameters: 

1. The `bytecode` of the contract: is the compiled version of the Smart Contract code.
2. A unique salt value: is a random number that is generated by the developer.
3. The `hash` of the code: is the hash of the bytecode of the contract.

### Benefits of using CREATE2:

1. **Deterministic contract creation:**:It allows developers to create Smart Contracts at deterministic addresses. This means that the address of the contract can be calculated before deployment, making it easier to interact with the contract.

2. **Cost savings**: Developers can save on gas fees. Since the contract address can be calculated before deployment, the contract can be created in a single transaction which reduces the number of transactions required to deploy a contract.

3. **Improved user experience**: Since the address of the contract is deterministic, users can easily predict the address of the contract and interact with it more easily.

4. **Contract upgradeability**: Developers can create contracts that can be upgraded without changing the contract address. This is because the new contract can be created with the same salt value as the old contract, which ensures that it has the same address.

5. **Better security**: Since the contract address can be calculated before deployment, it can be used to create contracts that are more secure and resistant to attacks. By precomputing the contract address, the contract can be deployed without revealing the contract code or the salt value which helps to prevent potential attacks.

 NB: If you try to deploy twice, it reverts. You can only deploy a contract with the same bytescode and the same salt once.

### Difference between CREATE and CREATE2 opcode:

| CREATE opcode:      | CREATE2 opcode: |
| ----------- | ----------- |
| 1. The address is determined by the factory contract's nonce.     | 1. creates a new contract at a deterministic address based on the provided salt value.        |
| 2. Factory nonce is increased by 1 Everytime CREATE is called   |  2. The address is not dependent on the the nonce of the factory when it's called.      |

In this tutorial, we will be making use of the cloned factory pattern.

## Tutorial:

### STEP 1 - Set up Hardhat Environment:

To begin setting up the Hardhat environment for your Smart Contract implementation, you will first need to create a new folder on your system. You can do this by using the `mkdir` command in your terminal followed by the desired name of your folder. For example:

```
mkdir Deployment-with-create2
```

Next, navigate to your project folder using the `cd` command, like so:

```
cd Deployment-with-create2
```

Once you have cd into the folder, you can initialize a new npm project inside it by running the following command:

```
npm init -y
```

This will create a “package.json” file in your project folder with default settings.
Run the following command to initialize the Hardhat environment and create some default configuration files and folders required for building and testing Smart Contracts.

```
npm install hardhat --save-dev
npx hardhat
```

We will be using a TypeScript project for this tutorial, so click on “Create a TypeScript project” and enter this and other prompt options.
<br/>

Finally, open your project folder in VScode by running this command in your terminal:

```
code 
```

This will open up your project folder in Visual Studio Code, where you can start setting up your Hardhat environment and writing your Smart Contract code.
<br/>

### STEP 2 - Create your Smart Contracts:

In the root directory of your project, you'll find a folder called "contracts". To create a new TypeScript file, simply navigate to this folder and add your new files.
<br/>

For this tutorial, we'll need to To create these two contracts files:

- Factory contract file.
- TestContract contract file.

#### Factory contract Explained:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./TestContract.sol";

contract Factory {
    // Event emitted when a new contract is deployed
    event DeployedContract(address indexed contractAddress);

    /**
     * @notice  A function to get bytecode of contract to be deployed
     * @dev     Returns bytes [bytes of TestContract + constructor argument]
     * @param   _owner An address[TestContract constructor arguments]
     * @param   _name  A string[TestContract constructor arguments]
     */
    function getContractBytecode(address _owner, string calldata _name) public pure returns (bytes memory) {
        // Get the bytecode of the TestContract
        bytes memory bytecode = type(TestContract).creationCode;
        // Append the constructor arguments to the bytecode
        return abi.encodePacked(bytecode, abi.encode(_owner, _name));
    }

    /**
     * @notice  A function to compute address of the contract to be deployed
     * @dev     Returns address where the contract will be deployed to if deployed with create2
     * @param   _salt     A unique bytes used to precompute an address
     * @param   _bytecode Byte code of the contract to be deployed
     */
    function getAddress(bytes32 _salt, bytes memory _bytecode) public view returns (address) {
        // Compute the predicted address of the contract
        address predictedAddress = address(uint160(uint(keccak256(
            abi.encodePacked(
                bytes1(0xff),
                address(this),
                _salt,
                keccak256(_bytecode)
            )
        ))));
        return predictedAddress;
    }

    /**
     * @notice  A function to create Contract using create2
     * @dev     Returns address of the new contract. Reverts if called with the same parameter more than once
     * @param   _salt     A unique bytes used to precompute an address
     * @param   _bytecode Byte code of the contract to be deployed
     */
    function createContract(bytes32 _salt, bytes memory _bytecode) public {
        // Create the contract using create2
        address contractAddress;
        assembly {
            contractAddress := create2(0, add(_bytecode, 0x20), mload(_bytecode), _salt)
            // Revert if the contract creation failed
            if iszero(extcodesize(contractAddress)) {
                revert(0, 0)
            }
        }
        // Ensure that the contract was deployed successfully
        require(contractAddress != address(0), "Factory: Failed to deploy contract");
        // Emit an event for the deployed contract
        emit DeployedContract(contractAddress);
    }

    /**
     * @notice  A helper function to get the bytes32 value of a number
     * @dev     Returns bytes32
     * @param   _salt  A unique uint value
     */
    function generateBytes(uint _salt) external pure returns(bytes32){
        // Convert the uint value to bytes32
        bytes32 salt = bytes32(_salt);
        return salt;
    }
}

```

The breakdown of the contract:

- The License was specified.
- The Solidity Version was set.
- The contract that we are deploying [Testcontract] is imported.

- `getContractBytecode()`: function returns the bytecode of the contract we want to deploy.`bytecode` is what the evm understand, our Solidity code is compiled to bytecode and stored on the evm so we can interact with it. It takes in the constructor argument of the contract we want to get the bytecode and encode the contract bytecode with the constructor parameter passed in to the function.

- `getAddress()` function: returns the Computed address of the contract to be deployed. It takes in the bytecode of the contract that we want to deploy and the salt.

Let's break down the formula to understand it better:

1. **`byte(0xff)`:**: is the first byte of the byte array that is used to create the contract.

2. **`address(this)`**: is the address of the current(factory) contract

3. **`salt`**: is the unique salt value that is generated by the developer.

4. **`keccak256(bytecode)`**: is the hash of the bytecode of the contract.

5. **`abi.encodePacked()`**:  is a function that concatenates the input arguments and returns bytes.

6. **`keccak256()`**:   is a function that computes the SHA-3 hash of the input.

5. **`address(uint160(uint(keccak256...)))`**:  computes the address of the contract by taking the last 20 bytes of the hash.

- `createContract()` function takes in two parameters: the `salt` and the `bytecode` of the contract. The **`createContract()`** function creates a new contract at a deterministic address based on the salt and bytecode using create2 opcode.

Inside the `createContract()` function, we defined a `contractAddress` variable to hold the address of the new contract. We then use assembly code to call the `create2` opcode to create the new contract. The assembly code takes in four parameters: 0 (value), `add(bytecode, 0x20)` (memory pointer to the bytecode), `mload(bytecode)`(length of the bytecode), and the `salt` value.

The if `iszero(extcodesize(contractAddress))` statement checks if the contract was successfully created. If the contract was not successfully created, the function reverts.

Finally, the `DeployedContract` event is emitted with the address of the new contract.

- `generateBytes()` function: is an helper function to compute the bytes32 value of any unsigned integer.

#### TestContract Explained:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TestContract {

    /** State Variable**/
    string public walletName;
    address public admin;

    // Modifier to check for caller of a function. It restrict Access to owner/admin
    modifier onlyAdmin() {
        require(admin == msg.sender, "Caller is not the owner");
        _;
    }

    /** 
    * @notice  constructor .runs on deployemnt of the contract. 
    * @param   _owner  . The Address of the admin/owner,
    * @param   _walletname  . The wallet name 
    **/
    constructor(address _owner, string memory _walletname) payable {
        require(_owner != address(0), "Invalid address");
        require(bytes(_walletname).length > 0, "Wallet name cannot be empty");
        admin = _owner;
        walletName = _walletname;
    }
    
    /**
     * @notice  . A function to transfer ownership to another user
     * @dev     . only admin/owner can call the function
     * @param   _newAdmin  . The Address of the new admin/owner
     */
    function transferOwnership(address _newAdmin) external onlyAdmin {
        require(_newAdmin != address(0), "Invalid address");
        require(_newAdmin != admin, "New admin cannot be the same as current admin");
        admin = _newAdmin;
    }

    /**
     * @notice  . A View Function to get the ether balance of the contract
     * @dev     . returns ether balance of the contract
     */
    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }

    /**
     * @notice  . A Function to withdraw the ether balance of the contract
     * @dev     . Only admin/owner can call the function
     */
    function withdraw() external onlyAdmin {
        require(address(this).balance > 0, "Insufficient balance");
        payable(msg.sender).transfer(address(this).balance);
    }

    /**
     * @notice  . A Function to receive ether sent directly to this contract without a function call.
     * @dev     . similar to a fallback function.
     */
    receive() external payable {
        require(msg.value > 0, "Invalid value");
    }
}

```
- `TestContract` is a simple wallet contract.

### STEP 3 - Deploying your contracts:

Before deploying your contract to the Celo testnet, ensure that you have added the Celo testnet RPC to your [Metamask wallet](https://metamask.io/download/), if not follow this [guide](https://docs.celo.org/blog/tutorials/3-simple-steps-to-connect-your-metamask-wallet-to-celo) to add it & also get faucet from this [site](https://faucet.celo.org/alfajores).
<br/>

Next, add the Celo network configuration to the "hardhat.config.ts" file located in the root directory of your project. To enable the use of your private key for your Celo account during contract deployment, you will need to install an "env" file. You can store your private key in the ".env" file and use the `dotenv` package to load it into your Hardhat configuration. Here is an example of how to configure it:

- Install the `dotenv` package:

```
npm install dotenv
```

- Create a ".env file" in the root directory of your project, paste your private key and `ETHERSCAN_API_KEY` into it:

```
PRIVATE_KEY=<your-private-key>
ETHERSCAN_API_KEY = <ETHERSCAN_API_KEY>
```

Here’s an example of how to add the Celo network configuration to your "hardhat.config.ts file":

```typescript
// Importing the HardhatUserConfig type from the hardhat/config module
import { HardhatUserConfig } from "hardhat/config";

// Importing the Hardhat toolbox module
import "@nomicfoundation/hardhat-toolbox";

// Importing the dotenv module and calling the config() method to load the environment variables
require("dotenv").config();

// Defining a type for HttpNetworkAccountsUserConfig
type HttpNetworkAccountsUserConfig = any;

// Creating a Hardhat configuration object
const config: HardhatUserConfig = {
  // Specifying the Solidity compiler version
  solidity: "0.8.0",
  
  // Configuring the "alfajores" network
  networks: {
    alfajores: {
      // Setting the URL for the Alfajores network RPC endpoint
      url: "https://alfajores-forno.celo-testnet.org",
      
      // Setting the accounts that will be used to deploy contracts and sign transactions
      accounts: [process.env.PRIVATE_KEY] as HttpNetworkAccountsUserConfig | undefined,
      
      // Setting the chain ID for the Alfajores network
      chainId: 44787,
    }
  },
  
  // Configuring Etherscan API key
  etherscan: {
    apiKey: process.env.ETHERSCAN_API_KEY
  }
};

// Exporting the configuration object
export default config;

```

Next thing is to write our deploy scripts:

```typescript
import { ethers } from "hardhat";

async function main() {
  try {
    const Factory = await ethers.getContractFactory("Factory");
    const factory = await Factory.deploy();

    await factory.deployed();

    console.log(`factory deployed to ${factory.address}`);

    /** Interact with the factory contract */
    const contract = await ethers.getContractAt("Factory", factory.address);

    //Get bytecode of a contract
    const bytecode = await contract.getContractBytecode("0x12896191de42EF8388f2892Ab76b9a728189260A", "SimpleWallet");
    console.log(bytecode);

    //generate bytes value of a number
    const salt = await contract.generateBytes(1);
    console.log("bytes of salt", salt);

    //get pre computed address of a contract
    const getAddress = await contract.getAddress(salt, bytecode);
    console.log("Pre computed address", getAddress);

    //deploy the contract
    const createContract = await contract.createContract(salt, bytecode);
    const txreceipt =  await createContract.wait()
    //@ts-ignore
    const txargs = txreceipt.events[0].args;
    //@ts-ignore
    const contractAddress = await txargs.contractAddress
    console.log("deployed address", contractAddress);

    /**Interact with the simple wallet contract */
    const TestContract = await ethers.getContractAt("TestContract", contractAddress);

    //Get the wallet Name
    const walletName = await TestContract.walletName();
    console.log("wallet name", walletName);

    const admin = await TestContract.admin();
    console.log("admin", admin);

    /**if you try to create a contract with the same bytecode and salt again. It revert because "Contract already created"*/
    //to deploy a replica of the contract, you need to change the salt value
    //const createContractagain = await contract.createContract(salt, bytecode);
  } catch (error) {
    console.error(error);
  }
}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main();

```

First, let's compile our Smart Contract using this command line in our VSCode terminal:

```
npx hardhat compile
```

Then, let’s deploy our contract using this command line in our VSCode terminal:

```
npx hardhat run scripts/deploy.ts --network alfajores
```

The breakdown of the script:

- Deployed the Factory contract and logged the factory `contract address`.
- Got the `bytecode` and log it(passing in the parameters required).
- Generated `salt` by passing 1 to it and also log it.
- Got precomputed address by passing salt and bytecode to it and also log it.
- Called the `createContract` function and passed in salt and bytecode and also log the result.
- Interacted with the `TestContract` contract passing in the deployed address.

You will discover that the deployed address and the precomputed address are the same thing.
So, before deployement we can always check for the contract address that will be generated when a particular bytecode is attached to a contract bytecode in **create2**

![Deployment Output](Images/deployed.png)

### Conclusion:

Therefore, deploying a contract with create2 on Celo allows you to pre-determine the contract's address before deploying it to the network, making it more efficient and cost-effective. This is achieved by calculating the address of the contract using the contract's bytecode, a salt value and the address of the creator account. By using create2, you can ensure that the contract address will be the same across different Ethereum-based networks, reducing the risk of errors or discrepancies. To deploy a contract with create2 on Celo, you can use the Celo SDK or web3.js library to interact with the Celo network and follow the specific steps outlined in the Celo documentation.

Hence, using CREATE2 in Solidity provides several benefits to developers like cost savings, improved user experience, contract upgradeability and better security.
<br/>

The link to my project repository can be found [here](https://github.com/Ultra-Tech-code/Deployment-with-create2).
